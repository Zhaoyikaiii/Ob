
随着目前前端工程日益复杂，某些业务或者工具库通常涉及到很多个仓库，那么时间一长，多个仓库开发弊端日益显露，由此出现了一种新的项目管理方式——Monorepo。

## 什么是 Monorepo?

Monorepo 其实不是一个新的概念，在软件工程领域，它已经有着十多年的历史了。概念上很好理解，就是把**多个项目**放在**一个仓库**里面，相对立的是传统的 MultiRepo 模式，即每个项目对应一个单独的仓库来分散管理。

![[Pasted image 20221128100824.png]]

现代的前端工程已经越来越离不开 Monorepo 了，无论是业务代码还是工具库，越来越多的项目已经采用 Monorepo 的方式来进行开发。Google 宁愿把所有的代码都放在一个 Monorepo 工程下面，Vue 3、Yarn、Npm7 等等知名开源项目的源码也是采用 Monorepo 的方式来进行管理的。

一般 Monorepo 的目录如下所示，在 packages 存放多个子项目，并且每个子项目都有自己的 `package.json` :

```json
├── packages |
├── pkg1 | |
├── package.json |
├── pkg2 | |
├── package.json
├── package.json
```

## MultiRepo 之痛

要想知道 Monorepo 的优势，首先得弄清楚之前的开发方式有什么痛点。

之前传统的方式 `MultiRepo` 当中，每个项目都对应单独的一个代码仓库。

### 1. 代码复用

在维护多个项目的时候，有一些逻辑可能会被多次用到，比如一些基础的组件，工具函数, 或者一些配置，你可能会想：要不把代码 copy，过来多省事。但是我们在代码中发现了一个 bug 就需要在多份拷贝之间去修复 BUG，维护的成本是非常高的。

那么如何解决这个问题呢？

比较好的办法是将公告的逻辑抽取出来，发布为一个新的 npm 包，一旦需要修改，只需要进行一次修改直接 publish 就可。

但这真的可以解决吗？

举个例子：
	我们项目中依赖一个工具函数，如果这个工具函数出现问题了，我们需要做的事情是：
		1. 去修改这个工具函数的代码。
		2. 发布 `1.1.1` 的新包。
		3. 在项目中使用这个新的 `1.1.1` 版本的工具函数。

可能我们只是修改了一行的代码，却需要进行这么多的流程。然而在开发阶段是很难保证自己写的代码不出 BUG。

上述的问题其实是 `MultiRepo` 普遍存在的问题，因为不同的仓库工作区的割裂，导致复用的成本很高，开发调试的流程繁琐，甚至在频繁改动的情况下让人感到很抓狂，体验感很差。

### 2. 版本控制

在 MultiRepo 的开发

