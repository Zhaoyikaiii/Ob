为了让程序在系统中运行程序，每条 c 语句都必须被其他程序转换为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序（executable object program) 的格式打好包，并以二进制磁盘文件的形式存放起来。
![[Pasted image 20230109192021.png]]

步骤一： 程序首先通过预处理器 (cpp) ，修改原始的 C 程序。比如 hello. c 的第一行 `#include<stdio.h>` 指令告诉预处理器读取系统头文件 `stdio.h` 的内容，并把它直接插入到程序文本中去。结果借的到了另一个 C 程序，通常是以 `.i` 作为文件拓展名。
步骤二： 编译器（ccl）将文本文件 `hello.i` 翻译成文本文件 `hello.s`，它包含了一个汇编语言程序。
- 汇编语言程序中的每条语句都以一种标准的文本格式确切地描述了一条低级机器语言指令
步骤三： 接下来，汇编器将 hello. s 翻译成机器语言指令，把这些指令打包成为一种叫做可重定位（relocatable）目标程序的格式，并将结果保存再目标文件 hello. o 中。hello. o 文件是一个二进制文件，它的字节码编码是机器语言指令而不是字符。
步骤四：连接阶段，在 hello 程序中调用的 printf 函数，它是一个标准 C 库中的函数，每个 C 编译器都提供。printf 函数存在于一个名为 printf. o 的单独的预编译目标文件中，而这个文编必须以某种方式并入到我们的 hello. o 程序中。链接器 (Id) 就负责处理这种并入，结果就得到 hello 文件。它是一个可执行目标文件, 加载到存储器后，由系统负责执行。

## 编译系统

理解代码是如何编译为机器代码，有助于程序员了解编译系统是如何工作的。

- 优化程序性能。
	- 一个 switch 语句的是否比一系列的 if - else 语句高效
	- 一个函数调用的代价是多大
	- while 循环比 do 循环更有效吗
	- 指针引用比数组索引更有效吗
	- 相对于通过引用传递过来的参数求和，为什么用本地遍历求和的循环，其运行就会快得多呢？
	- 为什么两个功能相近的循环的运行时间会有很大的差异？
- 理解链接时出现的错误。
	- 当试图处理大型的软件系统时。比如，链接器报告说它无法解析一个引用，这是什么意思？
	- 静态变量和全局变量的区别是什么？
	- 如果你在不同的 C 文件中定义了名字相同的两个变量会发生什么？
	- 静态库和动态库的区别是什么？
	- 为什么我们在命令行上排列库的顺序时有影响的？
	- 为什么有些连接错误知道运行时错误直到运行时才出现？
- 避免安全漏洞
	- 程序员忽略了编译器用来为函数产生代码的堆栈规则。

## 系统的硬件组成

为了了解运行程序时发生了什么，我们需要理解一个典型系统的硬件组织。
![[Pasted image 20230109194606.png]]

### 总线

是贯穿整个系统的一组电子管道。它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节快，也就是字（word）。

字中的字节数是一个基本的系统参数，在不同的 OS 中是不同的。

### IO 设备

是系统与外界联系的通道。每个 I/O 设备都是通过一个控制器或设配器与 I/O 总线连接起来的。控制器和配置器之间的区别主要在于它们的组成方式。控制器是 I/O 设备本身中或是系统的主印刷电路板（通常称为主板）上的芯片组，而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在 I/O 总线和 I/O 设备之间传递信息。

### 主存

是一个临时的存储设备，在处理器执行程序时，被用来存放程序和程序处理的数据。

在物理上，主存是由一组 DRAM (动态随机存取存储器) 芯片组成的。
在逻辑上，存储器是由一个线性的字节数组组成的，每个字节都有自己的唯一的地址（数组索引），从 0 开始。

### 处理器

是中央处理单元的简称，是解释（或执行）存储在贮存中指令的引擎。处理器的核心是一个称为程序计数器（PC）的字长大小的存储设备（或寄存器）。在任何一个时间点上，PC 都指向贮存中的某条机器语言指令（内含其地址）。

从系统通电开始，直到系统断电，处理器一直在不假思索地重复执行相同的基本任务：

- 从 PC 指向的存储器出读取指令，解释其中的为，指向指令指示的基本操作，然后更新程序计数器指向下一条指令，而这条指令并不一定在存储器中和刚刚指向的指令相邻
- 