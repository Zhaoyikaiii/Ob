## Shell 的类型

系统启动什么样的 shell 程序取决于你个人的用户 ID 配置。在 `/etc/passwd` 文件中，在用户 ID 记录的第 7 个字段中列出了默认的 shell 程序。只要用户登录到某个虚拟控制台中断或者在 GUI 中启动终端仿真器，默认的 shell 程序就会开始运行。

![[Pasted image 20221207071004.png]]


用于登录某个终端所启动的默认的 shell 是一个父 shell。在输入 `/bin/bash` 或者其他等效的 bash 命令时，会创建一个新的 shell 程序。这个 Shell 程序被称为是子 shell。

![[Pasted image 20221207071511.png]]

在运行 `ps -f` 的时候，会显示出两个进程。
其中一个进程的 PID 是 1841 运行的是  bash shell 程序，另一个进程的 PID 是 ` ps -f `

- 进程就是正在运行的程序。Bash shell 是一个程序，当他运行的时候，就成为了一个进程。一个运行着的 shell 就是某种进程而已。因此，在说到运行一个 bash shell 的时候，会经常看到 shell 和进程这两个词交换使用。
![[Pasted image 20221207071901.png]]
![[Pasted image 20221207072020.png]]

上面，使用 bash 创建了三个子 shell。 `ps -forest` 命令展示了这些子 shell 间的嵌套结构。
![[Pasted image 20221207072124.png]]

`ps -f` 命令也能表现子 shell 嵌套关系，因为它能够通过 PPID 列显示出谁是谁的父进程。

![[Pasted image 20221207072230.png]]

bash 命令可用的参数

![[Pasted image 20221207072307.png]]


#### 进程列表

你可以在一行中指定要依次执行的命令，通过分号（；）进行分隔。
![[Pasted image 20221207072639.png]]

上面的例子中，所有的命令依次执行，不存在任何问题。不过这并不是进程列表。命令列表想要称为进程列表，这些命令必须包含在括号里。

![[Pasted image 20221207072734.png]]

括号的加入使得命令列表编程了进程列表，生成了一个子 shell 来执行对应的命令。

使用花括号进行命令分组并不会像进程列表那样创建出子 shell

![[Pasted image 20221207073111.png]]

最后显示数字 0，就表示这些命令不是在 subShell 中执行的
![[Pasted image 20221207073213.png]]
最后显示数字 1，表明创建了子 Shell，并用于执行这些命令。
所以说，命令列表就是使用括号包围起来的一组命令，它能够创建出子 shell 来执行这些命令。
我们甚至可以在括号里面再继续嵌套括号表示子 Shell 的 shell

需要注意的是，再 shell 脚本中，经常使用子 shell 进行多线程处理。但是采用子 Shell 的成本不菲，会明显拖慢处理速度。再交互式的 CLI shell 会话中，子 shell 同样存在问题。它并非真正的多线程处理，因为终端控制着子 shell 的 I/O

#### shell 后台模式

在后台模式中运行命令可以子啊处理命令的同时让出 CLI，以供他用。演示后台模式的一个经典命令就是 sleep。

Sleep 命令接受一个参数，该参数是你希望进程等待的秒数。
`sleep 10` 会将绘画暂停 10 秒钟，然后返回 shell CLI 提示符

要想将命令置入后台模式，可以在命令末尾加上字符&。把 sleep 命令植入后台模式可以让我们利用 ps 命令。

![[Pasted image 20221207074237.png]]

方括号返回的是后台作业的 background job ID
第二条是后台作业的进程 ID 2396

除了 ps 命令，也可以使用 jobs 命令来显示后台作业信息。Jobs 命令可以显示出当前运行在后台模式中的所有用户进程