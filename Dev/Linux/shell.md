## Shell 的类型

系统启动什么样的 shell 程序取决于你个人的用户 ID 配置。在 `/etc/passwd` 文件中，在用户 ID 记录的第 7 个字段中列出了默认的 shell 程序。只要用户登录到某个虚拟控制台中断或者在 GUI 中启动终端仿真器，默认的 shell 程序就会开始运行。

![[Pasted image 20221207071004.png]]


用于登录某个终端所启动的默认的 shell 是一个父 shell。在输入 `/bin/bash` 或者其他等效的 bash 命令时，会创建一个新的 shell 程序。这个 Shell 程序被称为是子 shell。

![[Pasted image 20221207071511.png]]

在运行 `ps -f` 的时候，会显示出两个进程。
其中一个进程的 PID 是 1841 运行的是  bash shell 程序，另一个进程的 PID 是 ` ps -f `

- 进程就是正在运行的程序。Bash shell 是一个程序，当他运行的时候，就成为了一个进程。一个运行着的 shell 就是某种进程而已。因此，在说到运行一个 bash shell 的时候，会经常看到 shell 和进程这两个词交换使用。
![[Pasted image 20221207071901.png]]
![[Pasted image 20221207072020.png]]

上面，使用 bash 创建了三个子 shell。 `ps -forest` 命令展示了这些子 shell 间的嵌套结构。
![[Pasted image 20221207072124.png]]

`ps -f` 命令也能表现子 shell 嵌套关系，因为它能够通过 PPID 列显示出谁是谁的父进程。

![[Pasted image 20221207072230.png]]

bash 命令可用的参数

![[Pasted image 20221207072307.png]]


#### 进程列表

你可以在一行中指定要依次执行的命令，通过分号（；）进行分隔。
![[Pasted image 20221207072639.png]]

上面的例子中，所有的命令依次执行，不存在任何问题。不过这并不是进程列表。命令列表想要称为进程列表，这些命令必须包含在括号里。

![[Pasted image 20221207072734.png]]

括号的加入使得命令列表编程了进程列表，生成了一个子 shell 来执行对应的命令。

使用花括号进行命令分组并不会像进程列表那样创建出子 shell

![[Pasted image 20221207073111.png]]

最后显示数字 0，就表示这些命令不是在 subShell 中执行的
![[Pasted image 20221207073213.png]]
最后显示数字 1，表明创建了子 Shell，并用于执行这些命令。
所以说，命令列表就是使用括号包围起来的一组命令，它能够创建出子 shell 来执行这些命令。
我们甚至可以在括号里面再继续嵌套括号表示子 Shell 的 shell

需要注意的是，再 shell 脚本中，经常使用子 shell 进行多线程处理。但是采用子 Shell 的成本不菲，会明显拖慢处理速度。再交互式的 CLI shell 会话中，子 shell 同样存在问题。它并非真正的多线程处理，因为终端控制着子 shell 的 I/O

#### shell 后台模式

在后台模式中运行命令可以子啊处理命令的同时让出 CLI，以供他用。演示后台模式的一个经典命令就是 sleep。

Sleep 命令接受一个参数，该参数是你希望进程等待的秒数。
`sleep 10` 会将绘画暂停 10 秒钟，然后返回 shell CLI 提示符

要想将命令置入后台模式，可以在命令末尾加上字符&。把 sleep 命令植入后台模式可以让我们利用 ps 命令。

![[Pasted image 20221207074237.png]]

方括号返回的是后台作业的 background job ID
第二条是后台作业的进程 ID 2396

除了 ps 命令，也可以使用 jobs 命令来显示后台作业信息。Jobs 命令可以显示出当前运行在后台模式中的所有用户进程

### 协程

协程可以同时做两件事。它在后台生成了一个子 shell，并在这个子 shell 中执行命令。
要进行协程处理，得使用 coproc 命令，还有要在 shell 中执行的命令
`coproc sleep 10`
会对应的返回这个后台作业的作业好以及进程 ID
通过 `jobs` 可以获得这个协程的处理状态。
可以通过拓展语法自己设置起的进程名字
```shell
coproc My_Job { sleep 10; }
```

以拓展语法书写协程时，需要注意的是。必须确保在第一个花括号 `{` 和命令名之间有一个空格。
还必须要保证以分号结尾。另外，分号和闭花括号之间也得有一个空格。

- 协程能够让你尽情发挥想象力，发送或接收来自子 shell 中进程的信息。只有在拥有多个谢忱更多时候才需要对协程进行命名，因此你得和它们进行通信。否则的话，让 coproc 命令将其设置为默认的名字 `coproc` 就行了。

可以发挥想象，将协程和进程列表结合起来产生嵌套的子 shell。只需要输入进程列表，然后把命令 coproc 放在前面就行了。
```shell
coproc {
 sleep 10;
 sleep 2;
}
```

#### 理解 shell 的内建命令

在学习 GNU bash shell 期间，你可能听到过“内建命令”这个术语。搞明白 Shell 的内建命令和非内建 (外部) 命令非常重要。内建命令和非内建命令的操作方式大不相同。

##### 外部命令

外部命令，有时候也被称为是文件系统命令，是存在于 bash shell 之外的程序。它们并不是 shell 程序的一部分。外部命令程序通常位于 `/bin/`, `/usr/bin`, `/sbin`, `/usr/sbin` 中

ps 就是一个外部命令。可以通过 which 和 type 命令找到它。

![[Pasted image 20221207193345.png]]

当外部命令执行时，会创建出一个子进程。这种操作被称为衍生 (forking)。外部命令 ps 很方便显示出它的父进程以及自己所对应的衍生子进程。

当进程必须执行衍生操作时，他需要花费时间和精力来设置新的进程的环境。所以说，外部命令多少还是有待见的。

- 就算衍生出子进程或是创建了子 shell，你仍然可以通过发送信号与其沟通，这一点是无论是在命令行还是在脚本编写中都是极其有用的。发送信号 (signaling) 使得进程间可以通过信号进行通信。

#### 内建命令

内建命令和外部命令的区别在于前者不需要使用子进程来执行。它们已经和 shell 编译成立一体，作为 shell 工具的组成部分存在。不需要借助外部程序文件来运行。

所以内建命令一般执行速度更快，效率也更高。

需要注意的是，有些命令既有内建实现也有外部实现。两种实现略有不同。要查看命令的不同实现，可以使用 type 命令的-a 选项。
- which 只会显示出外部命令文件。

###### history

bash shell 会跟踪你用过的命令，你可以唤回这些命令并重新使用。
![[Pasted image 20221207194716.png]]

可以唤回并重用历史列表中最近的命令可以输入 `!!` 就可以唤出刚刚用过的那条命令来使用。

命令历史记录会保存在隐藏文件 `.bash_history` 中，它位于用户的主目录。这里需要注意的是，bash 命令的历史记录实现存在内存中，当 shell 退出时才会被写入到历史文件中。

