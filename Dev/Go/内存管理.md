### 关于内存管理的争论

- 内存管理太重要了！手动管理麻烦且容易出错，所以我们应该交给机器去管理！
- 内存管理太重要了！所以如果我们交给机器去管理我不能发放心。

### 堆内存管理

![[Pasted image 20221129065819.png]]
- 堆内存相对于栈的内存管理是比较复杂的，栈本身是和线程相关的，任何函数调用的时候，他相当于把函数中的局部变量和函数本身都压入栈，一旦函数结束了，栈这一层分配的变量都会被释放掉。所以栈相对于堆是非常简单的。
- `Allocator` : 有两个职责，他先跟 OS 要一块内存空间。之后会管理内存
- `Mutator` : 用户程序，通过 Mutator 向 Allocator 要内存空间
- · `Object Header` ：对象头，保存的是对对象的描述。
- `Collector` : 负责回收内存空间，会定期的扫描整个 Heap
	- 有哪些内存对象活跃，哪些对象不活跃，不活跃的会将内存回收

### 堆内存管理

- 初始化连续内存块作为堆
- 有内存申请的时候，Allocator 从堆内存的未分配区域分隔小内存块。
- 用链表将已分配内存连接起来
- 需要信息描述每个内存块的元数据：大小，是否使用，下一个内存块的地址等
- 内存回收就是描述堆内存，将不再被使用的内存设置为 unused
![[Pasted image 20221129071052.png]]

### 堆内存管理的挑战

内存分配需要系统调用，在频繁内存分配的时候，系统性能较低
多线程共享相同的内存空间，同时申请内存时，需要加锁，否则会产生同一块内存被多个线程访问的情况
内存碎片的问题，经过不断的内存分配和回收，内存碎片会比较严重，内存的使用效率较低
像 C/C++ 每新建一个变量都需要去 malloc 一块内存，假设这个程序是要频繁去 malloc 内存的程序，其实 malloc 就类似于是一个系统调用，我们知道系统调用也是有开销的，CPU 是需要从用户态切到内核态的。像 Java/Go 这样的语言一次直接按百分比去申请一块比较大的内存，这样的好处就是一次系统调用把所有需要的内存直接申请下来，剩下的时候只需要在用户态去分配。
在同一块内存空间的多线程是共用同一块内存空间的，如果多线程同时去申请内存时会出现竞争的

### ThreadCacheMalloc 概览

![[Pasted image 20221129072224.png]]
- 我们知道计算机是通过虚拟内存通过一个页表和偏移量映射到我们的实际的物理内存
- TCMalloc 会为每一个线程分配一块内存空间，这样的好处是。当本地的不同去申请内存时，会直接从本地的 ThreadCache 去取，如果本地有就直接返回，这个时候是不需要加锁的，因为内存地址不一样。
- 如果 ThreadCache 没有内存空间了，会到 CentralCache 去取。需要注意的是，ThreadCache 往 CentralCache 申请内存是按照页的大小去申请的
- 如果 CentralCache 也没有空间了会到 PageHeap 中去取
- 如果 PageHeap 也没有，会去操作系统中申请内存

理解 Span
	Span 是内存连续的不同页的组合，标准每个页为 8k
	按照不同大小的 Size class：8，16，32，48，64，80..

- page: 内存页，一块 8k 大小的内存空间。Go 与操作系统之间的内存申请和释放，都是以 Page 为单位的。
- span: 内存块，一个或多个连续的 page 组成一个 Span
- sizeclass: 空间规格，每个 span 都都有一个 sizeclass, 标记着该 span 中的 page 应该如何使用
- Object: 对象，用来存储一个变量数据内存空间，一个 span 在初始化时，会被切割成一堆等大的 object; 假设 Object 的大小是 16B, span 大小是 8K，那么就会把 span 中的 page 就会被初始化 8K/16B = 512 个 object。所谓内存分配，就是分配一个 object 出去。

- 对象大小定义
	- 小对象大小：0~256KB
	- 中对象大小：256KB~1MB
	- 大对象大小:>1MB
- 小对象的分配流程
	- ThreadCache -> CentralCache -> HeapPage, 大部分时候，ThreadCache 缓存都是足够的，不需要去访问 CentralCache 和 HeapPage, 无系统调用配合无锁分配，分配效率是非常高的。
- 中对象分配流程
	- 直接在 PageHeap 中选择适当大小的即可，128Page 的 Span 所保存的最大内存就是 1MB
- 大对象分配流程
	- 从 large span set 选择合适数量的页面组成 span, 用来存储数据

### Go 语言内存分配

就是从 TCMalloc 衍生过来的
![[Pasted image 20221129084709.png]]
- 但 Go 语言的内存分配与 TCmalloc 不同的是它的 span class 有 134 个，sizeclass 是 67 个，也就是同一类大小的 span class 的会占用两个 span。一个用来存指针，一个用来存直接引用的
