### 关于内存管理的争论

- 内存管理太重要了！手动管理麻烦且容易出错，所以我们应该交给机器去管理！
- 内存管理太重要了！所以如果我们交给机器去管理我不能发放心。

### 堆内存管理

![[Pasted image 20221129065819.png]]
- 堆内存相对于栈的内存管理是比较复杂的，栈本身是和线程相关的，任何函数调用的时候，他相当于把函数中的局部变量和函数本身都压入栈，一旦函数结束了，栈这一层分配的变量都会被释放掉。所以栈相对于堆是非常简单的。
- `Allocator` : 有两个职责，他先跟 OS 要一块内存空间。之后会管理内存
- `Mutator` : 用户程序，通过 Mutator 向 Allocator 要内存空间
- · `Object Header` ：对象头，保存的是对对象的描述。
- `Collector` : 负责回收内存空间，会定期的扫描整个 Heap
	- 有哪些内存对象活跃，哪些对象不活跃，不活跃的会将内存回收

### 堆内存管理

- 初始化连续内存块作为堆
- 有内存申请的时候，Allocator 从堆内存的未分配区域分隔小内存块。
- 用链表将已分配内存连接起来
- 需要信息描述每个内存块的元数据：大小，是否使用，下一个内存块的地址等
- 内存回收就是描述堆内存，将不再被使用的内存设置为 unused
![[Pasted image 20221129071052.png]]

### 堆内存管理的挑战

内存分配需要系统调用，在频繁内存分配的时候，系统性能较低
多线程共享相同的内存空间，同时申请内存时，需要加锁，否则会产生同一块内存被多个线程访问的情况
内存碎片的问题，经过不断的内存分配和回收，内存碎片会比较严重，内存的使用效率较低
像 C/C++ 每新建一个变量都需要去 malloc 一块内存，假设这个程序是要频繁去 malloc 内存的程序，其实 malloc 就类似于是一个系统调用，我们知道系统调用也是有开销的，CPU 是需要从用户态切到内核态的。像 Java/Go 这样的语言一次直接按百分比去申请一块比较大的内存，这样的好处就是一次系统调用把所有需要的内存直接申请下来，剩下的时候只需要在用户态去分配。
在同一块内存空间的多线程是共用同一块内存空间的，如果多线程同时去申请内存时会出现竞争的

### ThreadCacheMalloc 概览

![[Pasted image 20221129072224.png]]
- 我们知道计算机是通过虚拟内存通过一个页表和偏移量映射到我们的实际的物理内存
- TCMalloc 会为每一个线程分配一块内存空间，这样的好处是。当本地的不同去申请内存时，会直接从本地的 ThreadCache 去取，如果本地有就直接返回，这个时候是不需要加锁的，因为内存地址不一样。
- 如果 ThreadCache 没有内存空间了，会到 CentralCache 去取。需要注意的是，ThreadCache 往 CentralCache 申请内存是按照页的大小去申请的
- 如果 CentralCache 也没有空间了会到 PageHeap 中去取
- 如果 PageHeap 也没有，会去操作系统中申请内存

理解 Span
	Span 是内存连续的不同页的组合，标准每个页为 8k
	按照不同大小的 Size class：8，16，32，48，64，80..

- page: 内存页，一块 8k 大小的内存空间。Go 与操作系统之间的内存申请和释放，都是以 Page 为单位的。
- span: 内存块，一个或多个连续的 page 组成一个 Span
- sizeclass: 空间规格，每个 span 都都有一个 sizeclass, 标记着该 span 中的 page 应该如何使用
- Object: 对象，用来存储一个变量数据内存空间，一个 span 在初始化时，会被切割成一堆等大的 object; 假设 Object 的大小是 16B, span 大小是 8K，那么就会把 span 中的 page 就会被初始化 8K/16B = 512 个 object。所谓内存分配，就是分配一个 object 出去。

- 对象大小定义
	- 小对象大小：0~256KB
	- 中对象大小：256KB~1MB
	- 大对象大小:>1MB
- 小对象的分配流程
	- ThreadCache -> CentralCache -> HeapPage, 大部分时候，ThreadCache 缓存都是足够的，不需要去访问 CentralCache 和 HeapPage, 无系统调用配合无锁分配，分配效率是非常高的。
- 中对象分配流程
	- 直接在 PageHeap 中选择适当大小的即可，128Page 的 Span 所保存的最大内存就是 1MB
- 大对象分配流程
	- 从 large span set 选择合适数量的页面组成 span, 用来存储数据

### Go 语言内存分配

就是从 TCMalloc 衍生过来的
![[Pasted image 20221129084709.png]]
- 但 Go 语言的内存分配与 TCmalloc 不同的是它的 span class 有 134 个，sizeclass 是 67 个，也就是同一类大小的 span class 的会占用两个 span。一个用来存指针，一个用来存直接引用的 (需要考虑GC)

- mcache: 小对象的内存分配直接走
	- Size class 从 1 到 66 每个 Class 两个 span
	- San 大小是 8KB, 按 span class 大小切分
- mcentral
	- Span 内的所有内存块都被占用时，没有剩余空间继续分配对象，macche 会向 mcentral 申请 1 个 span, mcache 拿到 span 后继续分配对象
	- 当 mentral 向 mcache 提供 span 时，如果没有符合条件的 span, mcentral 会向 mheap 申请 span.
- mheap
	- 当 mheap 没有足够的内存时，mheap 会向 OS 申请内存
	- Mheap 把 Span 组织成了树的结构而不是链表
	- 然后把 Span 分配到 headArena 进行管理，它包含地址映射和 span 是否包含指针等位图
		- 为了更高效的分配，回收和再利用内存。

### 内存回收

- 引用计数 (Python, PHP, Swift)
		- 对每一个对象维护一个引用计数，当引用该独享的对象被销毁的时候，引用计数-1，当引用计数为 0 的时候，回收该对象。
		- 优点：对象可以很快的被回收，不会出现内存耗尽或达到某个阈值时才回收
		- 缺点：不能很好的处理循环引用，而且实时维护引用计数，有一定的代价
- 标记清除（Golang)
	- 从根变量开始遍历所有引用的对象，引用的对象标记为"被引用“，没有标记的会进行回收。
	- 优点：解决引用计数的缺点
	- 缺点：需要 STW (stop the word), 即要暂停程序运行。
- 分代收集 (Java)
	- 按照生命周期进行划分不同的代空间，生命周期长的放入老年代，短的放入新生代，新生代的回收频率高于老年代的频率。

### mspan

- allocBits
	-  记录了每块内存分配的情况
- gcmarkBites
	- 记录了每块内存的引用情况，标记阶段对每块内存进行标记，有对象引用的内存标记为 1，没有的标记为 0
![[Pasted image 20221129190755.png]]

 - 分配记录的是这个 span 有哪些内存是分配出去的
 - 标记位图：扫描之后记录有引用的标记为 1，未被引用的会被标记为 0

- 这两个位图的数据结构完全是一致的，标记结束则进行内存回收，回收的时候将 allocBits 指向 gcmarkBits, 标记过的则存在，未进行标记的则进行回收。
- ![[Pasted image 20221129191151.png]]

### GC 的工作流程

- Golang GC 的大部分处理时和用户代码并行的
	- Mark:
		- Mark Prepare: 初始化 GC 任务，包括开启写屏障（write barrier) 和辅助 GC（mutator assist), 统计 root 对象的任务数量等。这个过程需要 STW
		- GC Drains：扫描所有 root 对象，包括全局指针和 goroutine (G) 栈上的指针 (扫描对应 G 栈时需要停止该 G)，将起加入标记队列（灰色队列），并循环处理灰色队列的对象，知道灰色队列为空。该过程后天并行执行
	- Mark Termination: 完成标记工作，重新扫描（re-scan) 全局指针和栈，因为 Mark 和用户程序时并行的，所以再 Mark 过程中可能会有新的对象分配和指针赋值，这个时候就需要通过写屏障 (write barrier) 记录下来，re-scan 再检查一下，这个过程也是会 STW 的
	- Sweep：按照标记结果回收所有的白色对象，该过程后台并行执行
	- Sweep Termination: 对未清扫的 span 进行清扫，只有上一轮的 GC 的清扫工作完成才可以开始新一轮的 GC


### 三色标记

- GC 开始时，认为所有 object 都是白色，即垃圾。
- 从 root 区开始遍历，被触发的 object 置为灰色。
- 遍历所有灰色 object, 将他们内部的引用变量重置为灰色，自身置为黑色
- 循环第 3 步，知道没有灰色 object 了，之剩下了黑白两种，白色的都是垃圾。
- 对于黑色 object, 如果再标记期间发生了写操作，写屏障会在真正赋值前将新对象标记为灰色。
- 标记过程中，macllocgc 新分配的 object，会先被标记为黑色再返回。
![[Pasted image 20221129192821.png]]


### 垃圾回收触发机制

- 内存分配量达到阈值触发 GC
	- 每次内存分配时都会检查当前内存分配量是否已经达到阈值，如果达到阈值则立即启动 GC。
		- 阈值= 上次 GC 内存分配量 * 内存增长率
		- 内存增长率由环境变量 GOGC 控制，默认为 100，即每当内存扩大一倍时启动 GC。
	- 定期触发 GC
		- 默认情况下，最长 2 分钟触发一次 GC，这个间隔在 `src/runtime/proc.go:forcegcperiod` 变量中被声明
	- 手动触发
		- 程序代码中也可以使用 runtime. GC () 来手动触发 GC。这主要用于 GC 性能测试和统计。 
