### 关于内存管理的争论

- 内存管理太重要了！手动管理麻烦且容易出错，所以我们应该交给机器去管理！
- 内存管理太重要了！所以如果我们交给机器去管理我不能发放心。

### 堆内存管理

![[Pasted image 20221129065819.png]]
- 堆内存相对于栈的内存管理是比较复杂的，栈本身是和线程相关的，任何函数调用的时候，他相当于把函数中的局部变量和函数本身都压入栈，一旦函数结束了，栈这一层分配的变量都会被释放掉。所以栈相对于堆是非常简单的。
- `Allocator` : 有两个职责，他先跟 OS 要一块内存空间。之后会管理内存
- `Mutator` : 用户程序，通过 Mutator 向 Allocator 要内存空间
- · `Object Header` ：对象头，保存的是对对象的描述。
- `Collector` : 负责回收内存空间，会定期的扫描整个 Heap
	- 有哪些内存对象活跃，哪些对象不活跃，不活跃的会将内存回收

### 堆内存管理

- 初始化连续内存块作为堆
- 有内存申请的时候，Allocator 从堆内存的未分配区域分隔小内存块。
- 用链表将已分配内存连接起来
- 需要信息描述每个内存块的元数据：大小，是否使用，下一个内存块的地址等
- 内存回收就是描述堆内存，将不再被使用的内存设置为 unused
![[Pasted image 20221129071052.png]]

### 堆内存管理的挑战

内存分配需要系统调用，在频繁内存分配的时候，系统性能较低
多线程共享相同的内存空间，同时申请内存时，需要加锁，否则会产生同一块内存被多个线程访问的情况
内存碎片的问题，经过不断的内存分配和回收，内存碎片会比较严重，内存的使用效率较低
像 C/C++ 每新建一个变量都需要去 malloc 一块内存，假设这个程序是要频繁去 malloc 内存的程序，其实 malloc 就类似于是一个系统调用，我们知道系统调用也是有开销的，CPU 是需要从用户态切到内核态的。像 Java/Go 这样的语言一次直接按百分比去申请一块比较大的内存，这样的好处就是一次系统调用把所有需要的内存直接申请下来，剩下的时候只需要在用户态去分配。
在同一块内存空间的多线程是共用同一块内存空间的，如果多线程同时去申请内存时会出现竞争的

### ThreadCacheMalloc 概览

![[Pasted image 20221129072224.png]]
- 我们知道计算机是通过虚拟内存通过一个页表和偏移量映射到我们的实际的物理内存
- TCMalloc 会为每一个线程分配一块内存空间，这样的好处是。当本地的不同去申请内存时，会直接从本地的 ThreadCache 去取，如果本地有就直接返回，这个时候是不需要加锁的，因为内存地址不一样。
- 如果 ThreadCache 没有内存空间了，维护一个 CentralCache，会到 CentralCache 去取
- 如果 CentralCache 也没有空间了会到 PageHeap 中去取