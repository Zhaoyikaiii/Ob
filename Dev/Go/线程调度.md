## 深入理解 Go 语言线程调度

- 进程： 资源分配的基本单位
- 线程：调度的单位
- 无论是线程还是进程，在 linux 中都以 task_struct 描述，从内核角度看，与进程无本质的区别
- Glibc 中的 pthread 库提供 NPTL (Native POSIX THreading Library) 支持
	- 在内核层面，线程就是和主线程共享资源的`task_struct `

## Linux 进程的内存使用 
![[Pasted image 20221128195540.png]]

Linux 进程开销和切换进程的开销

	一个计算机的内存是固定的,在早期可能一个程序访问一个内存直接对应的就是一个物理内存。这样存在的问题是，如果多个进程之间抢同一块物理内存，是会出现问题的。
	随着技术的迭代就出现了虚拟地址，对于一个计算机，比如拥有4g的内存，这些内存的物理地址是固定的，每起一个应用进程的时候，也可以对这个进程虚拟4g的内存空间出来，这些4g的内存全是虚拟出来的虚拟地址。

	 - text： 指令大小，在引用启动时所有的代码会被加载为程序代码`size`命令可以看到。
	 - Data: 初始化数据，在整个程序load的时候一些静态变量需要被加载并被初始化
	 - BSS:未初始化数据，对于一些只是定义了，并没有给值的，这些数据会放入BSS。可以通过`objdump`查看。需要注意的是，Go语言并不支持静态变量，除非是写c的代码，通过go进行调用，否则写的代码是塞不进BSS和Data中的。
	 - dec = text + data + bss
- Kernel space
- 参数环境变量
- Stack：存储的是程序调用的上下文，会将方法的一些本地变量放入栈内。
- Heap：堆是动态分配的内存，放在一个全局的空间中，例如多线程访问的数据会被放入堆中
- 所以，堆是向下生长，栈是向上生长。
虚拟内存的目标是，是为了物理内存的复用，使得每起一个程序都可以拥有 4g 的虚拟内存。
其实在虚拟内存和物理内存之间是存在一个转化关系的，这个转化关系就是页表。所谓的页表就是，实际上就是物理内存和虚拟内存的对应关系。可以理解为是一个索引，给物理内存进行分页。分页大小可以通过 `getconf PAGE_SIZE` 命令获取，在 linux 一般一个页的大小为 4096k。

所以对于，物理内存，会将所有的内存按照 4k 的大小分为一个个的页。最终访问的物理地址就是这个索引的首地址，再加上一个偏移量。

对于虚拟地址，页表要记录很多很多的块地址。就会占用比较高的内存，怎么样去解决这个问题呢？那么就发展出了多级页表

- PGD: page global direactory
- PUD: page upper direactory
- PMD: page middle direactory 
- PT: page table

真正的物理内存相当于，通过这 4 级的索引找到 Table 在加上 offset 就是真正的物理地址。

物理内存最大只有 4G 但是多个进程每个进程都可以有 4G，那么是怎么做到整个程序不会超过 4g 的呢？

这就需要引出交换，有些时候我们只是声明了一块内存但并没有放东西，除此之外我们也是有磁盘的，我们可以将一些块交换出内存到磁盘，让其他的进程进来。

### CPU 对内存的访问

- CPU 上有个 Memory Management Unit (MMU) 单元
- CPU 把虚拟地址给 MMU, MMU 去物理内存中查询页表，得到实际物理地址。
- CPU 维护一份缓存 Translation Lookaside Buffer (TLB), 缓存虚拟地址和物理地址的映射关系。
- ![[Pasted image 20221128203426.png]]
这些操作的最终目的，就绪要尽可能的降低进程切换的开销，减少 IO

### 进程切换的开销包含什么

- 直接开销
	- 切换页表全局目录 (PGD)
	- 切换内核态堆栈
	- 切换硬件上下文 (进程恢复前，必须装入寄存器的数据称为硬件上下文)
	- 刷新 TLB
	- 系统调度器的代码执行
- 直接开销
	- CPU 缓存失效导致的进程需要到内存直接访问的 IO 操作变多。

### 线程切换开销

- 线程本质只是一批共享资源的进程，线程切换本质上依然需要内核进程切换
- 一组线程因为共享内存资源，因此一个进程的所有线程共享虚拟地址空间，线程切换相比进程切换，主要节省了虚拟地址空间的切换。

### 用户线程

无需内核帮助，应用程序在用户空间创建的可执行单元，创建销毁完全在用户态完成。
![[Pasted image 20221128204347.png]]

内核线程虽然需要交换页表，不切换虚拟地址，但是本身线程的切换还是通过系统调用进行的，系统调用意味着 CPU 的状态切换。在我们尽可能压榨 CPU 性能时性能就会降低。那么怎么解决这个问题?
那么我们是否有一种方式能够在用户态创建多个线程，从 kernel 的角度来说，这几个线程它就是线程。大家知道，所谓的多线程就是在一个 CPU 上跑多个线程，在以时间片的方式交替完成任务。那么，有没有可能我在用户态上起几个线程，在有效的 CPU 时间片里面，我尽量的，不用通过系统调用的方式切换到另外的线程，而是在用户态维护一个轻量级的线程队列，可以在程序的层面，让这些线程依次执行。
- 好处
	- 一旦拿到时间片，就可以在这个时间片内，尽力的完成任务，减少对系统调用的依赖。

## Goroutine

- Go 语言基于 GMP 模型实现用户态线程
	- Goroutine: 表示 goroutine, 每个 goroutine 都有自己的栈空间，定时器，初始化的栈空间在 2K 左右，空间会随着需求增长。
	- Machine：抽象化代表内核线程，记录内核线程栈信息，当 goroutine 调度到线程时，使用该 goroutine 自己的栈信息。可以类比 kernel 层面的，一个内核线程。
	- Process: 代表调度器，负责调度 goroutine, 维护一个本地 goroutine 队列，M 从 P 上获得 goroutine 并执行，同时还负责部分内存的管理。
![[Pasted image 20221128205855.png]]
GMP 中的 M 一般是与 CPU 一一对应的，允许建立很多很多的 G, 这些 G 就是用户态的轻量级的线程。这些轻量级的线程都会被放到一个队列里面，由 P 进行调度，P 会调度 G 上 M 执行。

### MPG 的对应关系

![[Pasted image 20221128210344.png]]

- 每个 CPU 对应一个 M, 内核线程和 M 是一一对应的
- P 和 M 之间是虚线，代表这种关系是不稳定的
- 每个 P 下维护G
- 需要通过 Go 语言的调度机制，使得 G 分配到不同的 M 里面，让他们去执行

### GMP 模型细节

![[Pasted image 20221128210702.png]]

- 在系统初始化时，会为每一个 CPU 初始化一个M
- 每个 M 会维护一个P
	- 假设，在程序启动之后。没有起任何的 Goroutine, 这些 P 其实是没有调度任务的
	- 还有正在运行的P
	- 一个 G 需要进行系统调用，CPU 本身陷入内核态，这个 P 就会和这个 M 解绑
- 每个 P 会维护一个 G 的队列
- 在新建 G 时，需要做栈的初始化，栈的初始化本身也有开销，在全局会有 gFree 列表，记录可重用的 G。我们可以看到除了每个 P 有一个 P G 队列，在全局也有一个 GRQ 的全局 G 队列，如果 P 的队列超过了 256 会放入全局的 G 队列

对于 G 如果被 M 调度执行，状态会变为 Grunning, 在 P 的队列中的 G 是 Grunnable 
对于处于阻塞状态的，可能是要去获取一个锁，从管道中读数据读取不到这种状态的 G 是处于 Gwaiting, 会被放到 sudog (阻塞队列)
在 P 的 G 队列永远是待执行的G.
也会存在一种情况就是，某个 P 的 G 个数一直是比较大的，其他的一些 P 的 G 个数是比较少的，对于 P 也会优先从全局的 G 队列中去拿 G，如果全局的 G 队列也是空的，它会直接从其他 P 的 G 队列中去拿 G。
当 G 执行完了，它不会立刻被销毁，会放入 gFree 中目的是复用

### P 的状态

- `_Piddle` : 处理器没有运行用户代码和胡总和调度器，被空闲队列或者改变起状态的结构持有，运行队列为空。
- `_Prunning` : 被线程 M 持有，并且真正该执行用户代码或者调度器
- `_Psyscall` : 没有执行用户代码，当前线程陷入系统调用
- `_Pgcstop` : 被线程 M 持有，当前处理器由于垃圾回收被停止
- `_Pdead` ：当前处理器已经不被使用。
![[Pasted image 20221128212945.png]]

### G 的状态

`_Gidle` : 刚刚被分配摈弃给还没有被初始化，值为 0，为创建 goroutine 后的默认值。
`_Grunnable` : 没有执行 diamagnetic，没有栈的所有权，存储在运行队列中，可能在某个 P 的本地队列或全局队列中。
`_Grunning` : 正在执行代码的 goroutine, 拥有栈的所有权。
`_Gsyscall` : 正在执行系统调用，拥有栈的所有权，与 P 脱离，到那时与某个 M 绑定，会在调度结束后被分配到运行队列
`_Gwaiting` : 被阻塞的 goroutine, 阻塞在某个 channel 的发送胡总和接收队列
`_Gdead` : 当前 goroutine 未被使用，没有执行代码，可能有分配的栈，分布在空闲列表 gFree, 可能是一个刚刚初始化的 goroutine, 也可能是执行了 goexit 退出 goroutine
`_Gcopystac` : 栈正在被拷贝，没有执行代码，不在运行队列上，执行权在。
`_Gscan` : GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在。

![[Pasted image 20221128213841.png]]

总结
- G 所处的位置
	- 全局的 G 队列
	- 每个 P 拥有自己的本地执行队列
	- 其他的不在运行队列中的G
		- 处于阻塞态的 G:sudog
		- 进行系统调用的，P 脱离 M 在执行队列中的G
		- 为了方便复用，执行结束后没有立马终止进入 gFree 的G

### Goroutine 创建过程

- 获取或者创建新的 Goroutine 结构体
	- 从处理器的 gFree 列表欧中查找空闲的 Goroutine 
	- 如果不存在空闲的 Goroutine, 会通过 `runtime.malg` 创建一个栈大小足够的新结构体。
- 将函数传入的参数移到 Goroutine 的栈上
- 更新 Goroutine 调度相关的属性，更新状态为 `_Grunnable`
- 返回的 Goroutine 会存储到 u 去安居变量 allgs 中

### 将 Goroutine 放到运行队列上

- Goroutine 设置到处理器的 runnext 作为下一个处理器执行的任务
- 当处理器的本地运行队列已经没有剩余空间时 (256), 就会把本地队列中的一部分 Goroutine 和待加入的 Goroutine 通过 `runtime.runqputslow` 添加到调度器持有的全局运行队列上。

### 调度器行为

- 为了保证公平，当全局运行队列中有待执行的 G 时，通过 schedtick 保证有一定几率 (1/61) 会从全局的运行队列中查找对应的 Goroutine （怕全局队列的 G 饿死）
- 从处理器本地的运行队列中查找待执行的G
- 如果前两种方法都没有找到 G, 会通过 runtime. findrunnable 进行阻塞地查找 G
	- 从本地运行队列，全局运行队列中查找
	- 从网络轮询器中查找是否有 Goroutine 等待运行
	- 通过 runtime. Runqsteal 尝试从其他随机的处理器中窃取一半待运行的G
