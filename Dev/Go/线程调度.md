## 深入理解 Go 语言线程调度

- 进程： 资源分配的基本单位
- 线程：调度的单位
- 无论是线程还是进程，在 linux 中都以 task_struct 描述，从内核角度看，与进程无本质的区别
- Glibc 中的 pthread 库提供 NPTL (Native POSIX THreading Library) 支持
	- 在内核层面，线程就是和主线程共享资源的`task_struct `

## Linux 进程的内存使用 
![[Pasted image 20221128195540.png]]

Linux 进程开销和切换进程的开销

	一个计算机的内存是固定的,在早期可能一个程序访问一个内存直接对应的就是一个物理内存。这样存在的问题是，如果多个进程之间抢同一块物理内存，是会出现问题的。
	随着技术的迭代就出现了虚拟地址，对于一个计算机，比如拥有4g的内存，这些内存的物理地址是固定的，每起一个应用进程的时候，也可以对这个进程虚拟4g的内存空间出来，这些4g的内存全是虚拟出来的虚拟地址。

	 - text： 指令大小，在引用启动时所有的代码会被加载为程序代码`size`命令可以看到。
	 - Data: 初始化数据，在整个程序load的时候一些静态变量需要被加载并被初始化
	 - BSS:未初始化数据，对于一些只是定义了，并没有给值的，这些数据会放入BSS。可以通过`objdump`查看。需要注意的是，Go语言并不支持静态变量，除非是写c的代码，通过go进行调用，否则写的代码是塞不进BSS和Data中的。
	 - dec = text + data + bss
- Kernel space
- 参数环境变量
- Stack：存储的是程序调用的上下文，会将方法的一些本地变量放入栈内。
- Heap：堆是动态分配的内存，放在一个全局的空间中，例如多线程访问的数据会被放入堆中
- 所以，堆是向下生长，栈是向上生长。
虚拟内存的目标是，是为了物理内存的复用，使得每起一个程序都可以拥有 4g 的虚拟内存。
其实在虚拟内存和物理内存之间是存在一个转化关系的，这个转化关系就是页表。所谓的页表就是，实际上就是物理内存和虚拟内存的对应关系。可以理解为是一个索引，给物理内存进行分页。分页大小可以通过 `getconf PAGE_SIZE` 命令获取，在 linux 一般一个页的大小为 4096k。

所以对于，物理内存，会将所有的内存按照 4k 的大小分为一个个的页。最终访问的物理地址就是这个索引的首地址，再加上一个偏移量。

对于虚拟地址，页表要记录很多很多的块地址。就会占用比较高的内存，怎么样去解决这个问题呢？那么就发展出了多级页表

- PGD: page global direactory
- PUD: page upper direactory
- PMD: page middle direactory 
- PT: page table

真正的物理内存相当于，通过这 4 级的索引找到 Table 在加上 offset 就是真正的物理地址。

物理内存最大只有 4G 但是多个进程每个进程都可以有 4G，那么是怎么做到整个程序不会超过 4g 的呢？

这就需要引出交换，有些时候我们只是声明了一块内存但并没有放东西，除此之外我们也是有磁盘的，我们可以将一些块交换出内存到磁盘，让其他的进程进来。

### CPU 对内存的访问

- CPU 上有个 Memory Management Unit (MMU) 单元
- CPU 把虚拟地址给 MMU, MMU 去物理内存中查询页表，得到实际物理地址。
- CPU 维护一份缓存 Translation Lookaside Buffer (TLB), 缓存虚拟地址和物理地址的映射关系。
- ![[Pasted image 20221128203426.png]]
这些操作的最终目的，就绪要尽可能的降低进程切换的开销，减少 IO

### 进程切换的开销包含什么

- 直接开销
	- 切换页表全局目录 (PGD)
	- 切换内核态堆栈
	- 切换硬件上下文 (进程恢复前，必须装入寄存器的数据称为硬件上下文)
	- 刷新 TLB
	- 系统调度器的代码执行
- 直接开销
	- CPU 缓存失效导致的进程需要到内存直接访问的 IO 操作变多。

### 线程切换开销

- 线程本质只是一批共享资源的进程，线程切换本质上依然需要内核进程切换
- 一组线程因为共享内存资源，因此一个进程的所有线程共享虚拟地址空间，线程切换相比进程切换，主要节省了虚拟地址空间的切换。

### 用户线程

无需内核帮助，应用程序在用户空间创建的可执行单元，创建销毁完全在用户态完成。
![[Pasted image 20221128204347.png]]

内核线程虽然需要交换页表，不切换虚拟地址，但是本身线程的切换还是通过系统调用进行的，系统调用意味着 CPU 的状态切换。在我们尽可能压榨 CPU 性能时性能就会降低。那么怎么解决这个问题?
那么我们是否有一种方式能够在用户态创建多个线程，从 kernel 的角度来说，这几个线程它就是线程。大家知道，所谓的多线程就是在一个 CPU 上跑多个线程，在以时间片的方式交替完成任务。那么，有没有可能我在用户态上起几个线程，在有效的 CPU 时间片里面，我尽量的，不用通过系统调用的方式切换到另外的线程，而是在用户态维护一个轻量级的线程队列，可以在程序的层面，让这些线程依次执行。
- 好处
	- 一旦拿到时间片，就可以在这个时间片内，尽力的完成任务，减少对系统调用的依赖。

## Goroutine

- Go 语言基于 GMP 模型实现用户态线程
	- Goroutine: 表示 goroutine, 每个 goroutine 都有自己的栈空间，定时器，初始化的栈空间在 2K 左右，空间会随着需求增长。
	- Machine：抽象化代表内核线程，记录内核线程栈信息，当 goroutine 调度到线程时，使用该 goroutine 自己的栈信息。可以类比 kernel 层面的，一个内核线程。
	- Process: 代表调度器，负责调度 goroutine, 维护一个本地 goroutine 队列，M 从 P 上获得 goroutine 并执行，同时还负责部分内存的管理。
![[Pasted image 20221128205855.png]]
GMP 中的 M 一般是与 CPU 一一对应的，允许建立很多很多的 G, 这些 G 就是用户态的轻量级的线程。这些轻量级的线程都会被放到一个队列里面，由 P 进行调度，P 会调度 G 上 M 执行。

### MPG 的对应关系

![[Pasted image 20221128210344.png]]

- 每个 CPU 对应一个 M, 内核线程和 M 是一一对应的
- P 和 M 之间是虚线，代表这种关系是不稳定的
- 每个 P 下维护G
- 需要通过 Go 语言的调度机制，使得 G 分配到不同的 M 里面，让他们去执行

### GMP 模型细节

![[Pasted image 20221128210702.png]]

- 在系统初始化时，会为每一个 CPU 初始化一个M
- 每个 M 会维护一个P
	- 假设，在程序启动之后。没有起任何的 Goroutine, 这些 P 其实是没有调度任务的
